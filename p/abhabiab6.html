<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>史上最详细的经典面试题 从输入URL到看到页面发生了什么？ | San‘qi Blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo.png">
    <script src="//sdk.51.la/js-sdk-pro.min.js" charset="UTF-8" id="LA_COLLECT"></script>
    <script src="/js/51la-init.js"></script>
    <meta name="description" content="坚持是对平庸最好的打击！">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/assets/css/0.styles.9e4cf6c1.css" as="style"><link rel="preload" href="/assets/js/app.81bafd78.js" as="script"><link rel="preload" href="/assets/js/2.b9d43781.js" as="script"><link rel="preload" href="/assets/js/10.6c300a3e.js" as="script"><link rel="prefetch" href="/assets/js/11.e52bf338.js"><link rel="prefetch" href="/assets/js/12.1bbc2313.js"><link rel="prefetch" href="/assets/js/13.c478d271.js"><link rel="prefetch" href="/assets/js/14.b9932d95.js"><link rel="prefetch" href="/assets/js/15.f0385aee.js"><link rel="prefetch" href="/assets/js/16.236a945f.js"><link rel="prefetch" href="/assets/js/17.abb2b50d.js"><link rel="prefetch" href="/assets/js/18.94cbf221.js"><link rel="prefetch" href="/assets/js/19.81e07c03.js"><link rel="prefetch" href="/assets/js/20.604417b8.js"><link rel="prefetch" href="/assets/js/21.dbe32356.js"><link rel="prefetch" href="/assets/js/22.ff538503.js"><link rel="prefetch" href="/assets/js/23.7465afe6.js"><link rel="prefetch" href="/assets/js/24.c213bb96.js"><link rel="prefetch" href="/assets/js/25.04a95982.js"><link rel="prefetch" href="/assets/js/3.4ffc4f47.js"><link rel="prefetch" href="/assets/js/4.b33bad8b.js"><link rel="prefetch" href="/assets/js/5.fd1ee6b9.js"><link rel="prefetch" href="/assets/js/6.dfbf0b78.js"><link rel="prefetch" href="/assets/js/7.0093bcf9.js"><link rel="prefetch" href="/assets/js/8.389c45b6.js"><link rel="prefetch" href="/assets/js/9.ae8fb281.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9e4cf6c1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div id="page" class="main_wrap"><div class="main_body"><div class="left_nav" data-v-2a48f59e><div class="left_nav_inner" data-v-2a48f59e><div class="top_logo" data-v-2a48f59e><a href="/" class="router-link-active" data-v-2a48f59e><span data-v-2a48f59e>San' qi</span>Blog
        </a></div> <div class="left_menu_box" data-v-2a48f59e><ul id="left_menu" class="menu" data-v-2a48f59e><li class="active" data-v-2a48f59e><a href="/" class="router-link-active" data-v-2a48f59e><i class="ri-home-line" data-v-2a48f59e></i> <span data-v-2a48f59e>首页</span></a></li> <li data-v-2a48f59e><a href="/circle" data-v-2a48f59e><i class="ri-edit-circle-line" data-v-2a48f59e></i> <span data-v-2a48f59e>圈儿</span></a></li><li data-v-2a48f59e><a href="/link" data-v-2a48f59e><i class="ri-link" data-v-2a48f59e></i> <span data-v-2a48f59e>友链</span></a></li><li data-v-2a48f59e><a href="/about" data-v-2a48f59e><i class="ri-at-line" data-v-2a48f59e></i> <span data-v-2a48f59e>关于</span></a></li></ul> <div class="adinfo_widget" data-v-2a48f59e><div class="wid_title" data-v-2a48f59e>Follow Me</div> <div class="items wid_ad_social" data-v-2a48f59e><a href="https://github.com/sanqi377" target="_blank" title="Github" class="ad_social" data-v-2a48f59e><i class="ri-github-line" data-v-2a48f59e></i></a> <a href="https://github.com/sanqi377" target="_blank" title="Bilibili" class="ad_social" data-v-2a48f59e><i class="ri-bilibili-line" data-v-2a48f59e></i></a> <a href="mailto:sanqi377@outlook.com" title="Send email" class="ad_social" data-v-2a48f59e><i class="ri-mail-send-line" data-v-2a48f59e></i></a></div></div></div></div></div> <div class="page_main"><header id="masthead" class="site-header"><div class="top_bar"><div class="top_left"><div class="top_tool"><a><i class="ri-contrast-2-line"></i></a></div> <div class="top_tool"><a><i class="ri-search-line s_toogle_btn"></i></a></div></div> <div class="top_right"><div class="top_tool"><a title="随机前往一个开往项目网站"><i class="ri-train-fill"></i></a></div></div></div></header> <div class="index_banner" style="background-image: url(/images/home_top_bg.jpg)"><div class="user_info"><div class="top"><div class="left"><div class="name">叁柒</div> <div class="des">楼外的蒹葭、傍晚的月亮和鸡鸣寺的樱花</div></div> <div class="avatar"><img src="/logo.png"></div></div></div></div> <div class="single_wrap" data-v-0621196e><div class="blog_header" data-v-0621196e><h2 class="entry-title" data-v-0621196e></h2> <ul data-v-0621196e><div class="header_meta" data-v-0621196e><span class="single_time" data-v-0621196e><i class="ri-time-line" data-v-0621196e></i> <time itemprop="datePublished" datetime="2022-10-10" data-v-0621196e>  2022-10-10</time></span> <span class="post_views" data-v-0621196e><i class="ri-eye-line" data-v-0621196e></i>25</span></div> <a href="/categories/undefined/" class="category" data-v-0621196e></a></ul></div> <div class="single-inner" data-v-0621196e><div class="single-content" data-v-0621196e><div class="content__default" data-v-0621196e><blockquote><p>转载来自稀土掘金：https://juejin.cn/post/6844903832435032072</p></blockquote> <h3 id="url的输入到浏览器解析的一系列事件"><a href="#url的输入到浏览器解析的一系列事件" class="header-anchor">#</a> URL的输入到浏览器解析的一系列事件</h3> <p>很多大公司面试喜欢问这样一道面试题，<code>输入URL到看见页面发生了什么？</code>,今天我们来总结一下。 简单来说，共有以下几个过程</p> <ul><li>DNS解析</li> <li>发起TCP连接</li> <li>发起HTTP请求</li> <li>服务器处理请求并返回HTTP报文</li> <li>浏览器解析渲染页面</li> <li>连接结束</li></ul> <h3 id="dns解析"><a href="#dns解析" class="header-anchor">#</a> DNS解析</h3> <p>DNS解析实际上是寻找你所需要的资源的过程。假设你输入<code>www.google.com</code>，而这个网址并不是谷歌的真实地址，互联网中的每一台机器都有唯一标识的IP地址，这个才是关键，但是它不好记，所以就需要一个网址和IP地址的转换，也就是DNS解析。下面看看具体的解析过程</p> <h3 id="具体解析"><a href="#具体解析" class="header-anchor">#</a> 具体解析</h3> <p>DNS解析其实是一个递归的过程</p> <p><img src="/images/16a634c9285cb545.webp" alt="DNS解析过程" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <p>输入 <code>www.google.com</code> 网址后，首先在本地的域名服务器下查找，没找到去根域名服务器去查找，没有再去 <code>.com</code> 顶级域名服务器去查找，如此类推下去，知道找到IP地址，然后把它记录在本地，供下次使用。大致过程就是 <code>.</code> -&gt; <code>.com</code> -&gt; <code>google.com.</code> -&gt; <code>www.google.com.</code></p> <h3 id="dns优化"><a href="#dns优化" class="header-anchor">#</a> DNS优化</h3> <p>既然已经懂得了解析的具体过程，我们可以看到上述一共经过了N个过程，每个过程有一定的消耗和时间的等待，因此我们得想办法解决一下这个问题！</p> <h4 id="dns缓存"><a href="#dns缓存" class="header-anchor">#</a> DNS缓存</h4> <p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p> <ul><li>在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。</li> <li>系统缓存主要存在/etc/hosts(Linux系统)中</li></ul> <h4 id="dns负载均衡"><a href="#dns负载均衡" class="header-anchor">#</a> DNS负载均衡</h4> <p>不知道你们有没有注意这样一件事，你访问 <code>baidu.com</code> 的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，假设只有一个服务器，那它的性能和存储量要多大才能支撑这样大量的访问呢？DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡</p> <h3 id="发起tcp连接"><a href="#发起tcp连接" class="header-anchor">#</a> 发起TCP连接</h3> <p>TCP提供一种可靠的传输，这个过程涉及到三次握手，四次挥手，下面我们详细看看 TCP提供一种面向连接的，可靠的字节流服务。 其首部的数据格式如下</p> <p><img src="/images/16a634dbf162e53c.webp" alt="发起TCP连接" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <h4 id="字段分析"><a href="#字段分析" class="header-anchor">#</a> 字段分析</h4> <ul><li>源端口：源端口和IP地址的作用是标识报文的返回地址。</li> <li>目的端口：端口指明接收方计算机上的应用程序接口。</li> <li>序号：是TCP可靠传输的关键部分。序号是该报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节都有一个序号。比如一个报文段的序号为300，报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。</li> <li>确认号：即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</li> <li>首部长度/数据偏移：占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8=60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</li> <li>保留：占6位，保留今后使用，但目前应都位0。</li> <li>控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能。
<ul><li>紧急URG：当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据</li> <li>确认ACK：仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1。</li> <li>推送PSH：当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1。</li> <li>复位RST：当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。</li> <li>同步SYN：在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1。</li> <li>终止FIN：用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放。</li></ul></li> <li>窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</li> <li>校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。</li> <li>紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</li> <li>选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</li> <li>数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</li></ul> <blockquote><p>需要注意的是： （A）不要将确认序号Ack与标志位中的ACK搞混了。 （B）确认方Ack=发起方Req+1，两端配对。</p></blockquote> <h4 id="三次握手"><a href="#三次握手" class="header-anchor">#</a> 三次握手</h4> <h5 id="第一次握手"><a href="#第一次握手" class="header-anchor">#</a> 第一次握手</h5> <p>客户端发送syn包(Seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p> <h5 id="第二次握手"><a href="#第二次握手" class="header-anchor">#</a> 第二次握手</h5> <p>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（Seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p> <h5 id="第三次握手"><a href="#第三次握手" class="header-anchor">#</a> 第三次握手</h5> <p>客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p> <p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p> <p><img src="/images/d8bf92c7906718271fdb8b0d2d5fe5b4.webp" alt="三次握手" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <h5 id="为什么会采用三次握手-若采用二次握手可以吗-四次呢"><a href="#为什么会采用三次握手-若采用二次握手可以吗-四次呢" class="header-anchor">#</a> 为什么会采用三次握手，若采用二次握手可以吗？ 四次呢？</h5> <p>建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。</p> <p>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。</p> <p>采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。而在三次握手中， client和server都有一个发syn和收ack的过程， 双方都是发后能收， 表明通信则准备工作OK.</p> <p>为什么不是四次握手呢？ 大家应该知道通信中著名的蓝军红军约定， 这个例子说明， 通信不可能100%可靠， 而上面的三次握手已经做好了通信的准备工作， 再增加握手， 并不能显著提高可靠性， 而且也没有必要。</p> <h4 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> 四次挥手</h4> <p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，假设客户端主动关闭，服务器被动关闭。</p> <p><img src="/images/8c7874fafe233c9278509e40e906055c.webp" alt="四次挥手" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <h5 id="第一次挥手"><a href="#第一次挥手" class="header-anchor">#</a> 第一次挥手</h5> <p>客户端发送一个FIN，用来关闭客户端到服务器的数据传送，也就是客户端告诉服务器：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可 以接受数据。
FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p> <h5 id="第二次挥手"><a href="#第二次挥手" class="header-anchor">#</a> 第二次挥手</h5> <p>服务器收到FIN包后，发送一个ACK给对方并且带上自己的序列号seq，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p> <p>此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p> <h5 id="第三次挥手"><a href="#第三次挥手" class="header-anchor">#</a> 第三次挥手</h5> <p>服务器发送一个FIN，用来关闭服务器到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p> <h5 id="第四次挥手"><a href="#第四次挥手" class="header-anchor">#</a> 第四次挥手</h5> <p>主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p> <p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p> <h4 id="为什么客户端最后还要等待2msl"><a href="#为什么客户端最后还要等待2msl" class="header-anchor">#</a> 为什么客户端最后还要等待2MSL？</h4> <p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p> <p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p> <p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p> <h4 id="为什么建立连接是三次握手-关闭连接确是四次挥手呢"><a href="#为什么建立连接是三次握手-关闭连接确是四次挥手呢" class="header-anchor">#</a> 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4> <p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p> <h3 id="发送http请求"><a href="#发送http请求" class="header-anchor">#</a> 发送HTTP请求</h3> <p>首先科补一个小知识，HTTP的端口为80/8080，而HTTPS的端口为443</p> <p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口 请求报文由请求行，请求报头，请求正文组成。</p> <h4 id="请求行"><a href="#请求行" class="header-anchor">#</a> 请求行</h4> <p>请求行的格式为 <code>Method Request-URL HTTP-Version CRLF eg: GET index.html HTTP/1.1</code> 常用的方法有: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>OPTIONS</code>, <code>HEAD</code>。</p> <h4 id="常见的请求方法区别"><a href="#常见的请求方法区别" class="header-anchor">#</a> 常见的请求方法区别</h4> <p>这里主要展示POST和GET的区别</p> <blockquote><p>常见的区别</p></blockquote> <ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li> <li>GET产生的URL地址可以被Bookmark，而POST不可以。</li> <li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li> <li>GET请求只能进行url编码，而POST支持多种编码方式。</li> <li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li> <li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li> <li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li> <li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li> <li>GET参数通过URL传递，POST放在Request body中。</li></ul> <blockquote><p>注意一点你也可以在GET里面藏body，POST里面带参数
重点区别</p></blockquote> <p><code>GET</code> 会产生一个 <code>TCP</code> 数据包，而 <code>POST</code> 会产生两个 <code>TCP</code> 数据包。</p> <p>详细的说就是：</p> <ul><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</li> <li>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</li></ul> <blockquote><p>注意一点，并不是所有的浏览器都会发送两次数据包，Firefox就发送一次</p></blockquote> <h4 id="请求报头"><a href="#请求报头" class="header-anchor">#</a> 请求报头</h4> <p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。</p> <p><img src="/images/16a634c93ecabe3a.webp" alt="请求报头" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <p>从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</p> <h4 id="请求正文"><a href="#请求正文" class="header-anchor">#</a> 请求正文</h4> <p>当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置 <code>Content-Type: application/json</code>。</p> <h4 id="更重要的事情-http缓存"><a href="#更重要的事情-http缓存" class="header-anchor">#</a> 更重要的事情-HTTP缓存</h4> <p>HTTP属于客户端缓存，我们常认为浏览器有一个缓存数据库，用来保存一些静态文件，下面我们分为以下几个方面来简单介绍HTTP缓存</p> <ul><li>缓存的规则</li> <li>缓存的方案</li> <li>缓存的优点</li> <li>不同刷新的请求执行过程</li></ul> <h5 id="缓存的规则"><a href="#缓存的规则" class="header-anchor">#</a> 缓存的规则</h5> <p>缓存规则分为<em>强制缓存</em>和<em>协商缓存</em></p> <h6 id="强制缓存"><a href="#强制缓存" class="header-anchor">#</a> 强制缓存</h6> <p>当缓存数据库中有客户端需要的数据，客户端直接将数据从其中拿出来使用（如果数据未失效），当缓存服务器没有需要的数据时，客户端才会向服务端请求。</p> <p><img src="/images/16a634c93d8f18a3.webp" alt="强制缓存" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <h6 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h6> <p>又称对比缓存。客户端会先从缓存数据库拿到一个缓存的标识，然后向服务端验证标识是否失效，如果没有失效服务端会返回304，这样客户端可以直接去缓存数据库拿出数据，如果失效，服务端会返回新的数据</p> <p><img src="/images/16a634c93d5e5406.webp" alt="协商缓存" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <blockquote><p>强制缓存的优先级高于协商缓存，若两种缓存皆存在，且强制缓存命中目标，则协商缓存不再验证标识。</p></blockquote> <h5 id="缓存的方案"><a href="#缓存的方案" class="header-anchor">#</a> 缓存的方案</h5> <p>上面的内容让我们大概了解了缓存机制是怎样运行的，但是，服务器是如何判断缓存是否失效呢？我们知道浏览器和服务器进行交互的时候会发送一些请求数据和响应数据，我们称之为HTTP报文。报文中包含首部header和主体部分body。与缓存相关的规则信息就包含在header中。boby中的内容是HTTP请求真正要传输的部分。举个HTTP报文header部分的例子如下：</p> <p><img src="/images/16a634c93ecabe3a.webp" alt="请求报头" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <p>分为强制缓存和协商缓存来分析。</p> <h6 id="强制缓存-2"><a href="#强制缓存-2" class="header-anchor">#</a> 强制缓存</h6> <p>对于强制缓存，服务器响应的header中会用两个字段来表明——Expires和Cache-Control。</p> <h6 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h6> <p>Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。</p> <h6 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-Control</h6> <p>Cache-Control有很多属性，不同的属性代表的意义也不同。</p> <ul><li>private：客户端可以缓存</li> <li>public：客户端和代理服务器都可以缓存</li> <li>max-age=t：缓存内容将在t秒后失效</li> <li>no-cache：需要使用协商缓存来验证缓存数据</li> <li>no-store：所有内容都不会缓存。</li></ul> <h6 id="协商缓存-2"><a href="#协商缓存-2" class="header-anchor">#</a> 协商缓存</h6> <p>协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。</p> <p>对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。</p> <h6 id="last-modified"><a href="#last-modified" class="header-anchor">#</a> Last-Modified</h6> <blockquote><p>Last-Modified：服务器在响应请求时，会告诉浏览器资源的最后修改时间。</p></blockquote> <ul><li><code>if-Modified-Since</code>:浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。
从字面上看，就是说：从某个时间节点算起，是否文件被修改了
<ul><li>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK</li> <li>如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified</li></ul></li> <li><code>if-Unmodified-Since</code>:从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改
<ul><li>如果没有被修改:则开始<code>继续</code>传送文件: 服务器返回: 200 OK</li> <li>如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)</li></ul></li></ul> <p>这两个的区别是一个是修改了才下载一个是没修改才下载。</p> <p>Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。</p> <h6 id="etag"><a href="#etag" class="header-anchor">#</a> Etag</h6> <blockquote><p>Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）</p></blockquote> <ul><li><code>If-None-Match</code>：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。
<ul><li>不同，说明资源被改动过，则响应整个资源内容，返回状态码200。</li> <li>相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304。</li></ul></li></ul> <p>但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。</p> <h5 id="缓存的优点"><a href="#缓存的优点" class="header-anchor">#</a> 缓存的优点</h5> <ul><li>减少了冗余的数据传递，节省宽带流量</li> <li>减少了服务器的负担，大大提高了网站性能</li> <li>加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因</li></ul> <h5 id="不同刷新的请求执行过程"><a href="#不同刷新的请求执行过程" class="header-anchor">#</a> 不同刷新的请求执行过程</h5> <ul><li><em>浏览器地址栏中写入URL，回车</em> <ul><li>浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）</li></ul></li> <li><em>F5</em> <ul><li>F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就战战兢兢的发送一个请求带上If-Modify-since。</li></ul></li> <li><em>Ctrl+F5</em> <ul><li>告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作.</li></ul></li></ul> <h3 id="服务器处理请求并返回http报文"><a href="#服务器处理请求并返回http报文" class="header-anchor">#</a> 服务器处理请求并返回HTTP报文</h3> <p>它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Nginx和Apache等等HTTP报文也分成三份，<em>状态码</em> ，<em>响应报头</em>和<em>响应报文</em></p> <h4 id="状态码"><a href="#状态码" class="header-anchor">#</a> 状态码</h4> <p>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p> <ul><li>1xx：指示信息–表示请求已接收，继续处理。</li> <li>2xx：成功–表示请求已被成功接收、理解、接受。</li> <li>3xx：重定向–要完成请求必须进行更进一步的操作。</li> <li>4xx：客户端错误–请求有语法错误或请求无法实现。</li> <li>5xx：服务器端错误–服务器未能实现合法的请求。</li></ul> <h4 id="常见状态码区别"><a href="#常见状态码区别" class="header-anchor">#</a> 常见状态码区别</h4> <ul><li><em>200 成功</em> <ul><li>请求成功，通常服务器提供了需要的资源。</li></ul></li> <li><em>204 无内容</em> <ul><li>服务器成功处理了请求，但没有返回任何内容。</li></ul></li> <li><em>301 永久移动</em> <ul><li>请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li></ul></li> <li><em>302 临时移动</em> <ul><li>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ul></li> <li><em>304 未修改</em> <ul><li>自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li></ul></li> <li><em>400 错误请求</em> <ul><li>服务器不理解请求的语法。</li></ul></li> <li><em>401 未授权</em> <ul><li>请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li></ul></li> <li><em>403 禁止</em> <ul><li>服务器拒绝请求。</li></ul></li> <li><em>404 未找到</em> <ul><li>服务器找不到请求的网页。</li></ul></li> <li><em>422 无法处理</em> <ul><li>请求格式正确，但是由于含有语义错误，无法响应</li></ul></li> <li><em>500 服务器内部错误</em> <ul><li>服务器遇到错误，无法完成请求。</li></ul></li></ul> <h4 id="响应报头"><a href="#响应报头" class="header-anchor">#</a> 响应报头</h4> <p>常见的响应报头字段有: Server, Connection...</p> <h4 id="响应报文"><a href="#响应报文" class="header-anchor">#</a> 响应报文</h4> <p>你从服务器请求的HTML,CSS,JS文件就放在这里面</p> <h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="header-anchor">#</a> 浏览器解析渲染页面</h3> <p><img src="/images/16a634c92a7439dc.webp" alt="浏览器解析渲染页面" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <p>就是 <code>Webkit</code> 解析渲染页面的过程。</p> <ul><li>解析HTML形成DOM树</li> <li>解析CSS形成CSSOM 树</li> <li>合并DOM树和CSSOM树形成渲染树</li> <li>浏览器开始渲染并绘制页面
这个过程涉及两个比较重要的概念回流和重绘，DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。浏览器刚打开页面一定要经过这两个过程的，但是这个过程非常非常非常消耗性能，所以我们应该尽量减少页面的回流和重绘</li></ul> <h3 id="性能优化之回流重绘"><a href="#性能优化之回流重绘" class="header-anchor">#</a> 性能优化之回流重绘</h3> <h4 id="回流"><a href="#回流" class="header-anchor">#</a> 回流</h4> <p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 会导致回流的操作：</p> <ul><li>页面首次渲染</li> <li>浏览器窗口大小发生改变</li> <li>元素尺寸或位置发生改变</li> <li>元素内容变化（文字数量或图片大小等等）</li> <li>元素字体大小变化</li> <li>添加或者删除可见的DOM元素</li> <li>激活CSS伪类（例如：:hover）</li> <li>查询某些属性或调用某些方法</li></ul> <p>一些常用且会导致回流的属性和方法：</p> <ul><li><code>clientWidth、clientHeight、clientTop、clientLeft</code></li> <li><code>offsetWidth、offsetHeight、offsetTop、offsetLeft</code></li> <li><code>scrollWidth、scrollHeight、scrollTop、scrollLeft</code></li> <li><code>scrollIntoView()、scrollIntoViewIfNeeded()</code></li> <li><code>getComputedStyle()</code></li> <li><code>getBoundingClientRect()</code></li> <li><code>scrollTo()</code></li></ul> <h4 id="重绘"><a href="#重绘" class="header-anchor">#</a> 重绘</h4> <p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p> <h4 id="优化"><a href="#优化" class="header-anchor">#</a> 优化</h4> <h5 id="css"><a href="#css" class="header-anchor">#</a> CSS</h5> <ul><li>避免使用table布局。</li> <li>尽可能在DOM树的最末端改变class。</li> <li>避免设置多层内联样式。</li> <li>将动画效果应用到position属性为absolute或fixed的元素上。</li> <li>避免使用CSS表达式（例如：calc()）。</li></ul> <h5 id="javascript"><a href="#javascript" class="header-anchor">#</a> JavaScript</h5> <ul><li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li> <li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li> <li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li> <li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li> <li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul> <h4 id="js的解析"><a href="#js的解析" class="header-anchor">#</a> JS的解析</h4> <p>JS的解析是由浏览器的JS引擎完成的。由于JavaScript是单线程运行，也就是说一个时间只能干一件事，干这件事情时其他事情都有排队，但是有些人物比较耗时（例如IO操作），所以将任务分为同步任务和异步任务，所有的同步任务放在主线程上执行，形成执行栈，而异步任务等待，当执行栈被清空时才去看看异步任务有没有东西要搞，有再提取到主线程执行，这样往复循环（冤冤相报何时了，阿弥陀佛），就形成了Event Loop事件循环，下面来看看大人物</p> <h5 id="event-loop"><a href="#event-loop" class="header-anchor">#</a> Event Loop</h5> <p>先看一段代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'定时器开始啦'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'马上执行for循环啦'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        i <span class="token operator">==</span> <span class="token number">99</span> <span class="token operator">&amp;&amp;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行then函数啦'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'代码执行结束'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>结果我想大家都应该知道。主要来介绍JavaScript的解析，至于Promise等下一节再说</p> <h5 id="javascript-2"><a href="#javascript-2" class="header-anchor">#</a> JavaScript</h5> <p>JavaScript是一门单线程语言，尽管H5中提出了 <code>Web-Worker</code>，能够模拟实现多线程，但本质上还是单线程，说它是多线程就是扯淡。</p> <h5 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h5> <p>既然是单线程，每个事件的执行就要有顺序，比如你去银行取钱，前面的人在进行，后面的就得等待，要是前面的人弄个一两个小时，估计后面的人都疯了，因此，浏览器的JS引擎处理JavaScript时分为<em>同步任务</em>和<em>异步任务</em></p> <p><img src="/images/16a634c9e9a32553.webp" alt="事件循环" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <p>这张图我们可以清楚看到</p> <ul><li>同步和异步任务分别进入不同的执行&quot;场所&quot;，同步的进入主线程，异步的进入Event Table并注册函数。</li> <li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li> <li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li> <li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul> <p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。
估计看完这些你对事件循环有一定的了解，但是事实上我们看对的没这么简单，通常我们会看到Promise，setTimeout，process.nextTick()，这个时候你和我就懵逼</p> <blockquote><p>除了同步任务和异步任务，我们还分为宏任务和微任务，常见的有以下几种</p></blockquote> <ul><li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li> <li>micro-task(微任务)：Promise，process.nextTick
不同任务会进入不同的任务队列来执行。 JS引擎开始工作后，先在宏任务中开始第一次循环（<code>script里面先执行，不过我喜欢把它拎出来，直接称其进入执行栈</code>），当主线程执行栈全部任务被清空后去微任务看看，如果有等待执行的任务，执行全部的微任务（其实将其回调函数推入执行栈来执行），再去宏任务找最先进入队列的任务执行，执行这个任务后再去主线程执行任务（例如执行 <code>console.log(&quot;hello world&quot;)</code> 这种任务），执行栈被清空后再去微任务，这样往复循环（冤冤相报何时了）</li></ul> <blockquote><p>Tip：微任务会全部执行，而宏任务会一个一个来执行</p></blockquote> <p>下面来看一段代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'then'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'console'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们看看它的执行情况</p> <ul><li>第一轮
<ul><li>这段代码进入主线程</li> <li>遇到setTimeout，将其回调函数注册后分发到宏任务</li></ul></li> <li>第二轮
<ul><li>遇到Promise，new Promise立即执行（这个不解释，想了解的我后续文章会介绍），输出 <code>promise</code>，遇到 <code>then</code>，将其分发到微任务</li></ul></li> <li>第三轮
<ul><li>遇到 <code>console.log(&quot;console&quot;)</code>,直接输出console</li></ul></li> <li>第四轮
<ul><li>主线程执行栈已经清空，先去微任务看看，执行then函数，输出 <code>then</code></li></ul></li> <li>第五轮
<ul><li>微任务执行完了，看看宏任务，有个setTimeout，输出 <code>setTimeout</code>，整体执行完毕。 具体的执行过程大致就是这样，可能我有疏忽的地方，还望指正。</li></ul></li></ul> <p><img src="/images/16a634ca0fddadd2.webp" alt="任务执行" loading="lazy" style="min-width:100px;min-height:100px;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) no-repeat center;background-size:30px 30px;"></p> <p>再来看看一段复杂的代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们来分析一下</p> <ul><li>整体script进入主线程，遇到 <code>console.log('1')</code>，直接输出</li> <li>遇到 <code>setTimeout</code>，将其回调函数分发到宏任务事件队列，暂时标记为setTimeout1</li> <li>遇到 <code>process.nextTick()</code>，将其回调函数分发到微任务事件队列，标记为process.nextTick1(这个地方有点出入，我一般认为<code>process.nextTick()</code>推入主线程执行栈栈底，作为执行栈最后一个任务执行)</li> <li>遇到Promise，立即执行，输出<code>7</code>，then函数分发的微任务事件队列，标记为Promise1。</li> <li>遇到setTimeout，将其回调函数分发到宏任务事件队列，标记为setTimeout2。</li> <li>现在已经输出了1,7,宏任务和微任务的事件队列</li> <li>现在主线程执行栈被清空，去微任务看看，发现有两个事件等待，由于队列是先进先出，执行 <code>process.nextTick1</code>,输出<code>6</code>，接着执行<code>Promise1</code>,输出<code>8</code>。</li></ul> <blockquote><p>至此，第一轮循环已经结束，输出了1,7,6,8,接下来执行第二轮循环 ，先从宏任务的setTimeout1开始</p></blockquote> <ul><li>遇到<code>console.log('2')</code>，执行输出。</li> <li>遇到<code>process.nextTick()</code>，将其回调函数分发到微任务，标记为<code>process.nextTick2</code>,又遇到 <code>Promise</code>，立即执行，输出<code>4</code>,将then函数推入微任务事件队列，标记为<code>Promise2</code></li> <li>到此宏任务的一个任务执行完毕，输出了<code>2,4</code></li> <li>去微任务看看，我们先处理<code>process.nextTick2</code>,输出<code>3</code>,接着再来执行<code>Promise2</code>,输出<code>5</code>。 第二轮循环执行完毕。现在一共输出了<code>1,7,6,8,2,4,3,5</code></li> <li>从<code>setTimeout2</code>开始第三轮循环 ，先直接输出<code>9</code>,遇到<code>process.nextTick()</code>，将其回调函数分发到微任务事件队列，标记为<code>process.nextTick3</code>,又遇到恶心的Promise，立即执行输出<code>11</code>，将then函数分发到微任务，标记为Promise3。</li> <li>执行微任务，看看还有撒子事件居然还有事件，能咋办，接着执行呗，输出<code>10,12</code>。 至此，全部任务执行完毕，输出顺序为<code>1,7,6,8,2,4,3,5,9,11,10,12</code>.</li></ul> <blockquote><p>注意，这段代码执行结果可能与node等环境不同而发生变化。</p></blockquote> <p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=2a88ju0jhmas0</p></div></div></div></div></div></div></div> <Comment></Comment></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.81bafd78.js" defer></script><script src="/assets/js/2.b9d43781.js" defer></script><script src="/assets/js/10.6c300a3e.js" defer></script>
  </body>
</html>
